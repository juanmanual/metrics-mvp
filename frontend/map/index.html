<html>
<head>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css"
   integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
   crossorigin=""/>
 <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"
   integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg=="
   crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
<script src="common.js?v7"></script>
</head>
<style type='text/css'>
#mapid { height: 100%; }
body { padding:0; margin:0; }

.controls, .legend, .trip-info
{
    border:1px solid #ccc;
    background-color:#fff;
    border-radius:5px;
    opacity:0.9;
}

.controls
{
    padding:5px;
}

.legend
{
    padding:2px 4px;
}

.trip
{
    padding:4px 4px;
}

.select-all a
{
    padding-right:2px;
    text-decoration:none;
}

.legend-colors div
{
    opacity:0.45;
    height:15px;
    width:30px;
    overflow:hidden;
    display:inline-block;
}
.legend-times div:first-child
{
    padding-left:15px;
}

.legend-times div
{
    text-align:center;
    width:30px;
    display:inline-block;
}

</style>
<body>
<div id="mapid"></div>
<script>

var map = L.map('mapid').setView([37.772,-122.442], 13);

loadJson('/config?r='+Math.random()).then(function(config) {
    if (config.mapbox_access_token)
    {
        var tileLayer = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
            maxZoom: 18,
            id: 'mapbox.streets',
            accessToken: config.mapbox_access_token
        }).addTo(map);
    }
}).catch(function(e) {
    showError("Error loading map config: " + e);
});

/*
var imageUrl = 'https://www.dropbox.com/s/sgnbbgef9r8f25j/sfmta-webmap-august2017-j2kl-0.8-256.png?dl=1',
    imageBounds = [[37.8363,-122.522], [37.7014,-122.3561]];
L.imageOverlay(imageUrl, imageBounds, {
    opacity:1,
    attribution: "SFMTA map &copy; 2017 David Wiggins and Jay Primus"
}).addTo(map);
*/

const isochroneMinutes = 5;

const maxColoredTripMin = 60;
const tripMinOptions = {
    5: {color:'#057F79'},
    10: {color:'#02BB0F'},
    15: {color:'#3ae100'},
    20: {color:'#83dd00'},
    25: {color:'#cad900'},
    30: {color:'#d59d00'},
    35: {color:'#d25400'},
    40: {color:'#ce0d00'},
    45: {color:'#c200b6'},
    50: {color:'#8b00bf'},
    55: {color:'#4900bf'},
    60: {color:'#220D3B'},
};

const defaultLayerOptions = {color:'#666'};

const defaultDisabledRoutes = [
    'PH','C','PM',
    'K_OWL','L_OWL','M_OWL','N_OWL','T_OWL',
    '41','88','90','91','714','S',
    'NX','1AX','1BX','7X','8AX','8BX','14X','30X','31AX','31BX','38AX','38BX','81X','82X','83X'
];

var isochroneLayers = [];
var layers = [];
var tripLayers = [];
var maxTripMin = 90;
var curDateStr = '2019-05-08';
var computedMaxTripMin;
var curComputeId;
var curLatLng;
var curEndLatLng;
var computeCache = {};

function resetMap() {
    map.closePopup();
    curComputeId = null;
    curLatLng = null;
    curEndLatLng = null;

    for (var isochroneLayer of isochroneLayers)
    {
        isochroneLayer.layer.remove();
    }
    for (var layer of layers)
    {
        layer.remove();
    }
    layers = [];
    isochroneLayers = [];
    clearTripLayers();
}

function clearTripLayers(clearTripInfo)
{
    for (var layer of tripLayers)
    {
        layer.remove();
    }
    tripLayers = [];

    if (clearTripInfo !== false)
    {
        tripInfo.innerHTML = '';
    }
}

function getDirectionInfo(directionId, routeInfo)
{
    for (var dirInfo of routeInfo.directions)
    {
        if (dirInfo.id == directionId)
        {
            return dirInfo;
        }
    }
    return null;
}

function setMaxTripMin(newMaxTripMin)
{
    maxTripMin = newMaxTripMin;

    if (computedMaxTripMin &&
        (newMaxTripMin > computedMaxTripMin || !isochroneLayers.find(iso => iso.tripMin === maxTripMin)))
    {
        recomputeIsochrones();
    }
    else
    {
        for (var isochroneLayer of isochroneLayers)
        {
            if (isochroneLayer.tripMin <= maxTripMin)
            {
                isochroneLayer.layer.addTo(map);
            }
            else
            {
                isochroneLayer.layer.remove();
            }
        }
    }
}

function showError(e) {
    alert(e);
}

var redIcon = new L.Icon({
  iconUrl: 'marker-icon-2x-red.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

async function showTripInfo(endLatLng, reachableCircles)
{
    curEndLatLng = endLatLng;

    var allOptions = [];
    for (var circle of reachableCircles)
    {
        var dist = map.distance(circle, endLatLng);
        if (dist <= circle.radius)
        {
            var walkMin = dist / WalkMetersPerMinute;
            var tripMin = walkMin + circle.tripMin;

            allOptions.push({
                tripMin: tripMin,
                walkMin: walkMin,
                circle: circle,
            });
        }
    }

    clearTripLayers(false);

    if (allOptions.length)
    {
        allOptions = allOptions.sort(function(o1, o2) {
            return o1.tripMin - o2.tripMin;
        });

        var seenRoutes = {};
        var numOptions = 0;

        var optionInfo = '';
        for (var option of allOptions)
        {
            var circle = option.circle;

            if (seenRoutes[circle.routes])
            {
                continue;
            }

            seenRoutes[circle.routes] = true;

            if (numOptions < 2 || !circle.tripItems.length)
            {
                numOptions++;

                for (tripItem of circle.tripItems)
                {
                    if (tripItem.route)
                    {
                        await loadRoute(tripItem.route)
                            .then(function(routeInfo) {
                                var dirInfo = getDirectionInfo(tripItem.direction, routeInfo);
                                var fromStopIndex = dirInfo.stops.indexOf(tripItem.fromStop);
                                var toStopIndex = dirInfo.stops.indexOf(tripItem.toStop);
                                if (fromStopIndex != -1 && toStopIndex != -1)
                                {
                                    var stopPoints = [];

                                    for (var i = fromStopIndex; i <= toStopIndex; i++)
                                    {
                                        var stopInfo = routeInfo.stops[dirInfo.stops[i]];
                                        stopPoints.push(stopInfo);
                                    }

                                    var polyLine = L.polyline(stopPoints).addTo(map);
                                    polyLine.bindTooltip(routeInfo.id, {direction:'center', opacity:0.9, permanent:true});

                                    tripLayers.push(polyLine);

                                    var fromStopInfo = routeInfo.stops[tripItem.fromStop];
                                    var toStopInfo = routeInfo.stops[tripItem.toStop];

                                    tripLayers.push(L.circle(fromStopInfo, 40, {color:'#090', fillOpacity:0.8, stroke:false}).addTo(map));
                                    tripLayers.push(L.circle(toStopInfo, 40, {color:'#900', fillOpacity: 0.8, stroke:false}).addTo(map));
                                }
                            }).catch(function(e) {
                                showError("Error loading route config: " + e);
                            });
                    }
                }

                optionInfo += "<div class='trip'><div><strong>" + option.tripMin.toFixed(1) + ' min ['+(circle.routes || 'walk')+']</strong></div>'
                    + circle.tripItems.map(function(item) {
                        return '<div><em>' + item.t.toFixed(1) + ' min</em>: '+item.desc+'</div>';
                    }).join('')
                    + (option.walkMin > 0.05 && circle.tripItems.length ? ('<div><em>' + option.walkMin.toFixed(1) + ' min</em>: walk to destination</div>') : '')
                    + "</div>";
            }
        }

        var marker = L.marker(endLatLng, {icon:redIcon}).addTo(map);

        tripLayers.push(marker);

        tripInfo.innerHTML = optionInfo;
    }

}

var isochroneWorker = new Worker('isochrone-worker.js?v=' + Math.random());

isochroneWorker.onmessage = function(e) {
    var data = e.data;
    if (data.type == 'reachableLocations')
    {
        var computeId = data.computeId;
        if (computeCache[computeId])
        {
            computeCache[computeId][data.tripMin] = data;
        }
        if (computeId == curComputeId)
        {
            addReachableLocationsLayer(data);
        }
    }
    else if (data.type == 'error')
    {
        showError(data.error);
    }
    else
    {
        console.log(e.data);
    }
}

function addReachableLocationsLayer(data)
{
    var tripMin = data.tripMin;
    var reachableCircles = data.circles;
    var geoJson = data.geoJson;

    var layerOptions = tripMinOptions['' + tripMin] || defaultLayerOptions;

    var diffLayer = L.geoJson(geoJson, Object.assign({bubblingMouseEvents: false, fillOpacity:0.4, stroke:false}, layerOptions));

    diffLayer.addTo(map);

    diffLayer.on('click', function(e) {
        var endLatLng = e.latlng;

        showTripInfo(endLatLng, reachableCircles);
    });

    diffLayer.on('dblclick', function(e) {
        resetMap();
        computeIsochrones(e.latlng);
    });

    isochroneLayers.push({tripMin: tripMin, layer: diffLayer});

    // restore end latlng from previous view
    if (curEndLatLng && !tripLayers.length)
    {
        for (var circle of reachableCircles)
        {
            var dist = map.distance(circle, curEndLatLng);
            if (dist <= circle.radius)
            {
                showTripInfo(curEndLatLng, reachableCircles);
                break;
            }
        }
    }
}

function isInServiceArea(latlng)
{
    const point = turf.point([latlng.lng, latlng.lat]);

    for (var feature of ServiceArea.features)
    {
        if (turf.booleanWithin(point, feature))
        {
            return true;
        }
    }
    return false;
}

function computeIsochrones(latlng, endLatLng)
{
    if (!isInServiceArea(latlng))
    {
        return;
    }

    curLatLng = latlng;
    curEndLatLng = endLatLng;
    computedMaxTripMin = maxTripMin;

    var enabledRoutes = getEnabledRoutes();

    var computeId = curComputeId = latlng.lat + ',' + latlng.lng + ',' + curDateStr + ',' + maxTripMin + ',' + enabledRoutes.join(',');

    var newLatLng;
    var marker = L.marker(latlng, {draggable: true}).addTo(map);
    marker.on('move', function(e) {
        newLatLng = e.latlng;
    });
    marker.on('moveend', function(e) {
        if (newLatLng)
        {
            resetMap();
            computeIsochrones(newLatLng);
        }
    });
    layers.push(marker);

    if (computeCache[computeId] && computeCache[computeId][maxTripMin])
    {
        for (var tripMin = isochroneMinutes; tripMin <= maxTripMin; tripMin += isochroneMinutes)
        {
            var cachedLayer = computeCache[computeId][tripMin];
            if (cachedLayer)
            {
                addReachableLocationsLayer(cachedLayer);
            }
        }
        return;
    }

    computeCache[computeId] = {};

    var tripMins = [];
    for (var m = isochroneMinutes; m <= maxTripMin && m <= maxColoredTripMin; m += isochroneMinutes)
    {
        tripMins.push(m);
    }
    if (maxTripMin > maxColoredTripMin)
    {
        tripMins.push(maxTripMin);
    }

    isochroneWorker.postMessage({
        action:'computeIsochrones',
        latlng: latlng,
        routes: enabledRoutes,
        dateStr: curDateStr,
        tripMins: tripMins,
        computeId: computeId
    });
}

map.on('click', function(e) {
    if (curComputeId)
    {
        return;
    }
    resetMap();
    computeIsochrones(e.latlng);
});


var legend = L.control({position:'bottomright'});
legend.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'legend');

    this._div.appendChild(document.createTextNode('trip times (minutes)'));

    var colorsContainer = document.createElement('div');
    colorsContainer.className = 'legend-colors';
    this._div.appendChild(colorsContainer);

    var timesContainer = document.createElement('div');
    timesContainer.className = 'legend-times';
    this._div.appendChild(timesContainer);

    for (var endTime = isochroneMinutes; endTime <= maxColoredTripMin; endTime += isochroneMinutes)
    {
        var colorContainer = document.createElement('div');
        colorContainer.style.backgroundColor = tripMinOptions[endTime].color;
        colorsContainer.appendChild(colorContainer);

        var timeContainer = document.createElement('div');
        timeContainer.innerHTML = '' + endTime;
        timesContainer.appendChild(timeContainer);
    }

    var colorContainer = document.createElement('div');
    colorContainer.style.backgroundColor = defaultLayerOptions.color;
    colorsContainer.appendChild(colorContainer);

    return this._div;
};
legend.addTo(map);

var tripInfoControl = L.control({position:'topright'});

var tripInfo = document.createElement('div');
tripInfo.className = 'trip-info';

tripInfoControl.onAdd = function(map) {
    return tripInfo;
};

tripInfoControl.addTo(map);

var routesContainer = document.createElement('div');

var routeCheckboxes = [];

function getEnabledRoutes()
{
    var routes = [];
    for (var checkbox of routeCheckboxes)
    {
        if (checkbox.checked)
        {
            routes.push(checkbox.value);
        }
    }
    return routes;
}

function recomputeIsochrones()
{
    var latlng = curLatLng;
    var endLatLng = curEndLatLng;
    if (latlng)
    {
        resetMap();
        computeIsochrones(latlng, endLatLng);
    }
}

//var defaultEnabledRoutes = ['27','76X'];

function selectAllRoutes(checked)
{
    for (checkbox of routeCheckboxes)
    {
        checkbox.checked = checked;
    }
    recomputeIsochrones();
}

loadJson('/routes').then(function(routes) {

    for (var route of routes) {
        var routeContainer = document.createElement('div');
        var label = document.createElement('label');
        routeContainer.appendChild(label);
        var routeCheckbox = document.createElement('input');
        routeCheckbox.type = 'checkbox';
        routeCheckbox.value = route.id;
        //routeCheckbox.checked = defaultEnabledRoutes.indexOf(route.id) != -1 ? 'checked' : '';
        routeCheckbox.checked = defaultDisabledRoutes.indexOf(route.id) == -1 ? 'checked' : '';

        routeCheckbox.addEventListener('click', function(e) {
            recomputeIsochrones();
        });
        routeCheckboxes.push(routeCheckbox);

        label.appendChild(routeCheckbox);

        label.appendChild(document.createTextNode(' ' + route.id));
        routesContainer.appendChild(routeContainer);
    }
}).catch(function(e) {
    showError("Error loading routes: " + e);
});

var controls = L.control({position:'topleft'});

controls.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'controls');
    this._div.addEventListener('click', function(e) {
        e.stopPropagation();
    });
    this._div.addEventListener('dblclick', function(e) {
        e.stopPropagation();
    });

    var dateSelect = document.createElement('select');
    for (var dateStr of ['2019-04-08','2019-05-08','2019-05-11'])
    {
        var option = document.createElement('option');
        option.value = '' + dateStr;
        option.appendChild(document.createTextNode(dateStr));
        dateSelect.appendChild(option);
    }
    dateSelect.value = '' + curDateStr;
    dateSelect.addEventListener('change', function() {
        curDateStr = dateSelect.value;
        recomputeIsochrones();
    });
    dateSelect.style.display = 'block';
    dateSelect.style.marginBottom = '5px';

    this._div.appendChild(document.createTextNode('date:'));
    this._div.appendChild(dateSelect);

    var tripMinSelect = document.createElement('select');
    for (var tripMin = isochroneMinutes; tripMin <= 90; tripMin += isochroneMinutes)
    {
        var option = document.createElement('option');
        option.value = '' + tripMin;
        option.appendChild(document.createTextNode(tripMin + ' minutes'));
        tripMinSelect.appendChild(option);
    }
    tripMinSelect.value = '' + maxTripMin;

    tripMinSelect.addEventListener('change', function() {
        setMaxTripMin(parseInt(tripMinSelect.value, 10));
    });
    tripMinSelect.style.display = 'block';
    tripMinSelect.style.marginBottom = '5px';

    this._div.appendChild(document.createTextNode('max trip time:'));
    this._div.appendChild(tripMinSelect);

    routesContainer.style.overflow = 'auto';
    routesContainer.style.maxHeight = '150px';

    this._div.appendChild(document.createTextNode('routes:'));

    var allLink = document.createElement('a');
    allLink.href = 'javascript:void(0)';
    allLink.innerHTML = 'all';
    allLink.addEventListener('click', function() {
        selectAllRoutes(true);
    });
    var noneLink = document.createElement('a');
    noneLink.href = 'javascript:void(0)';
    noneLink.innerHTML = 'none';
    noneLink.addEventListener('click', function() {
        selectAllRoutes(false);
    });

    var selectAll = document.createElement('div');
    selectAll.className = 'select-all';

    selectAll.appendChild(allLink);
    selectAll.appendChild(document.createTextNode(' / '));
    selectAll.appendChild(noneLink);
    this._div.appendChild(selectAll);
    this._div.appendChild(routesContainer);

    var reset = document.createElement('button');
    reset.innerHTML = "Clear";
    reset.addEventListener('click', function(e) {
        resetMap();
    });
    this._div.appendChild(reset);

    return this._div;
};

controls.addTo(map);
</script>
</body>
</html>
