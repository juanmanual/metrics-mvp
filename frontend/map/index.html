<html>
<head>
 <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css"
   integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
   crossorigin=""/>
 <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"
   integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg=="
   crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
<script src="common.js?v10"></script>
</head>
<style type='text/css'>
#mapid { height: 100%; }
body { padding:0; margin:0; }

.controls, .legend, .trip-info
{
    border:1px solid #ccc;
    background-color:#fff;
    border-radius:5px;
    opacity:0.9;
}

.controls
{
    padding:5px;
}

.legend
{
    padding:2px 4px;
}

.trip
{
    padding:4px 4px;
}

.select-all a
{
    padding-right:2px;
    text-decoration:none;
}

.legend-colors div
{
    opacity:0.45;
    height:15px;
    width:30px;
    overflow:hidden;
    display:inline-block;
}
.legend-times div:first-child
{
    padding-left:15px;
}

.legend-times div
{
    text-align:center;
    width:30px;
    display:inline-block;
}

</style>
<body>
<div id="mapid"></div>
<script>

let map = L.map('mapid').setView([37.772,-122.442], 13);

loadJson('/config?r='+Math.random()).then(function(config) {
    if (config.mapbox_access_token)
    {
        let tileLayer = L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
            maxZoom: 18,
            id: 'mapbox.streets',
            accessToken: config.mapbox_access_token
        }).addTo(map);
    }
}).catch(function(e) {
    showError("Error loading map config: " + e);
});

/*
let imageUrl = 'https://www.dropbox.com/s/sgnbbgef9r8f25j/sfmta-webmap-august2017-j2kl-0.8-256.png?dl=1',
    imageBounds = [[37.8363,-122.522], [37.7014,-122.3561]];
L.imageOverlay(imageUrl, imageBounds, {
    opacity:1,
    attribution: "SFMTA map &copy; 2017 David Wiggins and Jay Primus"
}).addTo(map);
*/

const isochroneMinutes = 5;

const maxColoredTripMin = 60;
const tripMinOptions = {
    5: {color:'#057F79'},
    10: {color:'#02BB0F'},
    15: {color:'#3ae100'},
    20: {color:'#83dd00'},
    25: {color:'#cad900'},
    30: {color:'#d59d00'},
    35: {color:'#d25400'},
    40: {color:'#ce0d00'},
    45: {color:'#c200b6'},
    50: {color:'#8b00bf'},
    55: {color:'#4900bf'},
    60: {color:'#220D3B'},
};

const defaultLayerOptions = {color:'#666'};

const defaultDisabledRoutes = [
    'PH','C','PM',
    'K_OWL','L_OWL','M_OWL','N_OWL','T_OWL',
    '41','88','90','91','714','S',
    'NX','1AX','1BX','7X','8AX','8BX','14X','30X','31AX','31BX','38AX','38BX','81X','82X','83X'
];

let isochroneLayers = [];
let layers = [];
let tripLayers = [];
let maxTripMin = 90;
let curDateStr = '2019-06-06';
let curTimeStr = '';
let curStat = 'median';
let computedMaxTripMin;
let curComputeId;
let curLatLng;
let curEndLatLng;
let computeCache = {};

function resetMap() {
    map.closePopup();
    curComputeId = null;
    curLatLng = null;
    curEndLatLng = null;

    for (let isochroneLayer of isochroneLayers)
    {
        isochroneLayer.layer.remove();
    }
    for (let layer of layers)
    {
        layer.remove();
    }
    layers = [];
    isochroneLayers = [];
    clearTripLayers();
}

function clearTripLayers(clearTripInfo)
{
    for (let layer of tripLayers)
    {
        layer.remove();
    }
    tripLayers = [];

    if (clearTripInfo !== false)
    {
        tripInfo.innerHTML = '';
    }
}

function getDirectionInfo(directionId, routeInfo)
{
    for (let dirInfo of routeInfo.directions)
    {
        if (dirInfo.id === directionId)
        {
            return dirInfo;
        }
    }
    return null;
}

function setMaxTripMin(newMaxTripMin)
{
    maxTripMin = newMaxTripMin;

    if (computedMaxTripMin &&
        (newMaxTripMin > computedMaxTripMin || !isochroneLayers.find(iso => iso.tripMin === maxTripMin)))
    {
        recomputeIsochrones();
    }
    else
    {
        for (let isochroneLayer of isochroneLayers)
        {
            if (isochroneLayer.tripMin <= maxTripMin)
            {
                isochroneLayer.layer.addTo(map);
            }
            else
            {
                isochroneLayer.layer.remove();
            }
        }
    }
}

function showError(e) {
    alert(e);
}

let redIcon = new L.Icon({
  iconUrl: 'marker-icon-2x-red.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

async function showTripInfo(endLatLng, reachableCircles)
{
    curEndLatLng = endLatLng;

    let allOptions = [];
    for (let circle of reachableCircles)
    {
        let dist = map.distance(circle, endLatLng);
        if (dist <= circle.radius)
        {
            let walkMin = dist / WalkMetersPerMinute;
            let tripMin = walkMin + circle.tripMin;

            allOptions.push({
                tripMin: tripMin,
                walkMin: walkMin,
                circle: circle,
            });
        }
    }

    clearTripLayers(false);

    if (allOptions.length)
    {
        allOptions = allOptions.sort(function(o1, o2) {
            return o1.tripMin - o2.tripMin;
        });

        let seenRoutes = {};
        let numOptions = 0;

        let optionInfo = '';
        for (let option of allOptions)
        {
            let circle = option.circle;

            if (seenRoutes[circle.routes])
            {
                continue;
            }

            seenRoutes[circle.routes] = true;

            if (numOptions < 2 || !circle.tripItems.length)
            {
                numOptions++;

                for (tripItem of circle.tripItems)
                {
                    if (tripItem.route)
                    {
                        await loadRoute(tripItem.route)
                            .then(function(routeInfo) {
                                let dirInfo = getDirectionInfo(tripItem.direction, routeInfo);
                                let fromStopIndex = dirInfo.stops.indexOf(tripItem.fromStop);
                                let toStopIndex = dirInfo.stops.indexOf(tripItem.toStop);
                                if (fromStopIndex !== -1 && toStopIndex !== -1)
                                {
                                    let stopPoints = [];

                                    for (let i = fromStopIndex; i <= toStopIndex; i++)
                                    {
                                        let stopInfo = routeInfo.stops[dirInfo.stops[i]];
                                        stopPoints.push(stopInfo);
                                    }

                                    let polyLine = L.polyline(stopPoints).addTo(map);
                                    polyLine.bindTooltip(routeInfo.id, {direction:'center', opacity:0.9, permanent:true});

                                    tripLayers.push(polyLine);

                                    let fromStopInfo = routeInfo.stops[tripItem.fromStop];
                                    let toStopInfo = routeInfo.stops[tripItem.toStop];

                                    tripLayers.push(L.circle(fromStopInfo, 40, {color:'#090', fillOpacity:0.8, stroke:false}).addTo(map));
                                    tripLayers.push(L.circle(toStopInfo, 40, {color:'#900', fillOpacity: 0.8, stroke:false}).addTo(map));
                                }
                            }).catch(function(e) {
                                showError("Error loading route config: " + e);
                            });
                    }
                }

                optionInfo += "<div class='trip'><div><strong>" + option.tripMin.toFixed(1) + ' min ['+(circle.routes || 'walk')+']</strong></div>'
                    + circle.tripItems.map(function(item) {
                        return '<div><em>' + item.t.toFixed(1) + ' min</em>: '+item.desc+'</div>';
                    }).join('')
                    + (option.walkMin > 0.05 && circle.tripItems.length ? ('<div><em>' + option.walkMin.toFixed(1) + ' min</em>: walk to destination</div>') : '')
                    + "</div>";
            }
        }

        let marker = L.marker(endLatLng, {icon:redIcon}).addTo(map);

        tripLayers.push(marker);

        tripInfo.innerHTML = optionInfo;
    }

}

let isochroneWorker = new Worker('isochrone-worker.js?v=' + Math.random());

isochroneWorker.onmessage = function(e) {
    let data = e.data;
    if (data.type === 'reachableLocations')
    {
        let computeId = data.computeId;
        if (computeCache[computeId])
        {
            computeCache[computeId][data.tripMin] = data;
        }
        if (computeId === curComputeId)
        {
            addReachableLocationsLayer(data);
        }
    }
    else if (data.type === 'error')
    {
        showError(data.error);
    }
    else
    {
        console.log(e.data);
    }
}

function addReachableLocationsLayer(data)
{
    let tripMin = data.tripMin;
    let reachableCircles = data.circles;
    let geoJson = data.geoJson;

    let layerOptions = tripMinOptions['' + tripMin] || defaultLayerOptions;

    let diffLayer = L.geoJson(geoJson, Object.assign({bubblingMouseEvents: false, fillOpacity:0.4, stroke:false}, layerOptions));

    diffLayer.addTo(map);

    diffLayer.on('click', function(e) {
        let endLatLng = e.latlng;

        showTripInfo(endLatLng, reachableCircles);
    });

    diffLayer.on('dblclick', function(e) {
        resetMap();
        computeIsochrones(e.latlng);
    });

    isochroneLayers.push({tripMin: tripMin, layer: diffLayer});

    // restore end latlng from previous view
    if (curEndLatLng && !tripLayers.length)
    {
        for (let circle of reachableCircles)
        {
            let dist = map.distance(circle, curEndLatLng);
            if (dist <= circle.radius)
            {
                showTripInfo(curEndLatLng, reachableCircles);
                break;
            }
        }
    }
}

function isInServiceArea(latlng)
{
    const point = turf.point([latlng.lng, latlng.lat]);

    for (let feature of ServiceArea.features)
    {
        if (turf.booleanWithin(point, feature))
        {
            return true;
        }
    }
    return false;
}

function computeIsochrones(latlng, endLatLng)
{
    if (!isInServiceArea(latlng))
    {
        return;
    }

    curLatLng = latlng;
    curEndLatLng = endLatLng;
    computedMaxTripMin = maxTripMin;

    let enabledRoutes = getEnabledRoutes();

    let computeId = curComputeId = latlng.lat + ',' + latlng.lng + ',' + curDateStr + ',' + curTimeStr + ',' + curStat + ',' + maxTripMin + ',' + enabledRoutes.join(',');

    let newLatLng;
    let marker = L.marker(latlng, {draggable: true}).addTo(map);
    marker.on('move', function(e) {
        newLatLng = e.latlng;
    });
    marker.on('moveend', function(e) {
        if (newLatLng)
        {
            resetMap();
            computeIsochrones(newLatLng);
        }
    });
    layers.push(marker);

    if (computeCache[computeId] && computeCache[computeId][maxTripMin])
    {
        for (let tripMin = isochroneMinutes; tripMin <= maxTripMin; tripMin += isochroneMinutes)
        {
            let cachedLayer = computeCache[computeId][tripMin];
            if (cachedLayer)
            {
                addReachableLocationsLayer(cachedLayer);
            }
        }
        return;
    }

    computeCache[computeId] = {};

    let tripMins = [];
    for (let m = isochroneMinutes; m <= maxTripMin && m <= maxColoredTripMin; m += isochroneMinutes)
    {
        tripMins.push(m);
    }
    if (maxTripMin > maxColoredTripMin)
    {
        tripMins.push(maxTripMin);
    }

    isochroneWorker.postMessage({
        action:'computeIsochrones',
        latlng: latlng,
        routes: enabledRoutes,
        dateStr: curDateStr,
        timeStr: curTimeStr,
        tripMins: tripMins,
        stat: curStat,
        computeId: computeId
    });
}

map.on('click', function(e) {
    if (curComputeId)
    {
        return;
    }
    resetMap();
    computeIsochrones(e.latlng);
});


let legend = L.control({position:'bottomright'});
legend.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'legend');

    this._div.appendChild(document.createTextNode('trip times (minutes)'));

    let colorsContainer = document.createElement('div');
    colorsContainer.className = 'legend-colors';
    this._div.appendChild(colorsContainer);

    let timesContainer = document.createElement('div');
    timesContainer.className = 'legend-times';
    this._div.appendChild(timesContainer);

    for (let endTime = isochroneMinutes; endTime <= maxColoredTripMin; endTime += isochroneMinutes)
    {
        let colorContainer = document.createElement('div');
        colorContainer.style.backgroundColor = tripMinOptions[endTime].color;
        colorsContainer.appendChild(colorContainer);

        let timeContainer = document.createElement('div');
        timeContainer.innerHTML = '' + endTime;
        timesContainer.appendChild(timeContainer);
    }

    let colorContainer = document.createElement('div');
    colorContainer.style.backgroundColor = defaultLayerOptions.color;
    colorsContainer.appendChild(colorContainer);

    return this._div;
};
legend.addTo(map);

let tripInfoControl = L.control({position:'topright'});

let tripInfo = document.createElement('div');
tripInfo.className = 'trip-info';

tripInfoControl.onAdd = function(map) {
    return tripInfo;
};

tripInfoControl.addTo(map);

let routesContainer = document.createElement('div');

let routeCheckboxes = [];

function getEnabledRoutes()
{
    let routes = [];
    for (let checkbox of routeCheckboxes)
    {
        if (checkbox.checked)
        {
            routes.push(checkbox.value);
        }
    }
    return routes;
}

function recomputeIsochrones()
{
    let latlng = curLatLng;
    let endLatLng = curEndLatLng;
    if (latlng)
    {
        resetMap();
        computeIsochrones(latlng, endLatLng);
    }
}

//let defaultEnabledRoutes = ['27','76X'];

function selectAllRoutes(checked)
{
    for (checkbox of routeCheckboxes)
    {
        checkbox.checked = checked;
    }
    recomputeIsochrones();
}

loadJson('/routes').then(function(routes) {

    for (let route of routes) {

        let defaultEnabled = defaultDisabledRoutes.indexOf(route.id) === -1;
        //let defaultEnabled = defaultEnabledRoutes.indexOf(route.id) !== -1;
        if (defaultEnabled)
        {
            // preload route data before user clicks
            loadRoute(route.id)
                .then(function(routeInfo) {})
                .catch(function(e) {
                    console.log("error preloading route config: " + e);
                });
        }

        let routeContainer = document.createElement('div');
        let label = document.createElement('label');
        routeContainer.appendChild(label);
        let routeCheckbox = document.createElement('input');
        routeCheckbox.type = 'checkbox';
        routeCheckbox.value = route.id;
        routeCheckbox.checked = defaultEnabled ? 'checked' : '';

        routeCheckbox.addEventListener('click', function(e) {
            recomputeIsochrones();
        });
        routeCheckboxes.push(routeCheckbox);

        label.appendChild(routeCheckbox);

        label.appendChild(document.createTextNode(' ' + route.id));
        routesContainer.appendChild(routeContainer);
    }
}).catch(function(e) {
    showError("Error loading routes: " + e);
});

let controls = L.control({position:'topleft'});

controls.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'controls');
    this._div.addEventListener('click', function(e) {
        e.stopPropagation();
    });
    this._div.addEventListener('dblclick', function(e) {
        e.stopPropagation();
    });

    let dateSelect = document.createElement('select');
    for (let dateStr of ['2019-06-06'])
    {
        let option = document.createElement('option');
        option.value = '' + dateStr;
        option.appendChild(document.createTextNode(dateStr));
        dateSelect.appendChild(option);
    }
    dateSelect.value = '' + curDateStr;
    dateSelect.addEventListener('change', function() {
        curDateStr = dateSelect.value;
        recomputeIsochrones();
    });
    dateSelect.style.display = 'block';
    dateSelect.style.marginBottom = '5px';

    this._div.appendChild(document.createTextNode('date:'));
    this._div.appendChild(dateSelect);

    this._div.appendChild(document.createTextNode('time range:'));

    let timeSelect = document.createElement('select');
    var timeOptions = {
        '': 'All day',
        '07:00-19:00': 'Daytime',
        '03:00-07:00': 'Early morning',
        '07:00-10:00': 'AM Peak',
        '10:00-16:00': 'Midday',
        '16:00-19:00': 'PM Peak',
        '19:00-03:00+1': 'Late Evening',
    };
    for (let timeRange in timeOptions)
    {
        let option = document.createElement('option');
        option.value = timeRange;
        option.appendChild(document.createTextNode(timeOptions[timeRange]));
        timeSelect.appendChild(option);
    }
    timeSelect.value = '';
    timeSelect.addEventListener('change', function() {
        curTimeStr = timeSelect.value;
        recomputeIsochrones();
    });
    timeSelect.style.display = 'block';
    timeSelect.style.marginBottom = '5px';

    this._div.appendChild(timeSelect);

    this._div.appendChild(document.createTextNode('stat:'));

    let statSelect = document.createElement('select');
    var statOptions = {
        'p10': '10th percentile',
        'median': 'median',
        'avg': 'average',
        'p90': '90th percentile',
    };
    for (let stat in statOptions)
    {
        let option = document.createElement('option');
        option.value = stat;
        option.appendChild(document.createTextNode(statOptions[stat]));
        statSelect.appendChild(option);
    }
    statSelect.value = 'median';
    statSelect.addEventListener('change', function() {
        curStat = statSelect.value;
        recomputeIsochrones();
    });
    statSelect.style.display = 'block';
    statSelect.style.marginBottom = '5px';

    this._div.appendChild(statSelect);

    let tripMinSelect = document.createElement('select');

    function addTripMinOption(tripMin) {
        let option = document.createElement('option');
        option.value = '' + tripMin;
        option.appendChild(document.createTextNode(tripMin + ' minutes'));
        tripMinSelect.appendChild(option);
    }

    for (let tripMin = isochroneMinutes; tripMin <= maxColoredTripMin; tripMin += isochroneMinutes)
    {
        addTripMinOption(tripMin);
    }
    addTripMinOption(90);
    tripMinSelect.value = '' + maxTripMin;

    tripMinSelect.addEventListener('change', function() {
        setMaxTripMin(parseInt(tripMinSelect.value, 10));
    });
    tripMinSelect.style.display = 'block';
    tripMinSelect.style.marginBottom = '5px';

    this._div.appendChild(document.createTextNode('max trip time:'));
    this._div.appendChild(tripMinSelect);

    routesContainer.style.overflow = 'auto';
    routesContainer.style.maxHeight = '150px';

    this._div.appendChild(document.createTextNode('routes:'));

    let allLink = document.createElement('a');
    allLink.href = 'javascript:void(0)';
    allLink.innerHTML = 'all';
    allLink.addEventListener('click', function() {
        selectAllRoutes(true);
    });
    let noneLink = document.createElement('a');
    noneLink.href = 'javascript:void(0)';
    noneLink.innerHTML = 'none';
    noneLink.addEventListener('click', function() {
        selectAllRoutes(false);
    });

    let selectAll = document.createElement('div');
    selectAll.className = 'select-all';

    selectAll.appendChild(allLink);
    selectAll.appendChild(document.createTextNode(' / '));
    selectAll.appendChild(noneLink);
    this._div.appendChild(selectAll);
    this._div.appendChild(routesContainer);

    let reset = document.createElement('button');
    reset.innerHTML = "Clear";
    reset.addEventListener('click', function(e) {
        resetMap();
    });
    this._div.appendChild(reset);

    return this._div;
};

controls.addTo(map);
</script>
</body>
</html>
